---
title: "Atelier 10: Analyses multivari√©es avanc√©es"
subtitle: "S√©rie d'ateliers R"
author: "Centre de la Science de la Biodiversit√© du Qu√©bec"
output:
  xaringan::moon_reader:
    includes:
      in_header: qcbsR-header.html
    lib_dir: assets
    seal: true
    css: ["default", "qcbsR.css", "qcbsR-fonts.css"]
    nature:
      beforeInit: "qcbsR-macros.js"
      highlightLines: true
      highlightStyle: github
---


```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  comment = "#",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  fig.width = 6, fig.height = 6,
  fig.retina = 3,
  fig.align = 'center'
)
options(repos=structure(c(CRAN="http://cran.r-project.org")))
```

class: inverse, center, middle

```{r install_pkgs, message=FALSE, warning=FALSE, include=FALSE, results=0}
# Standard procedure to check and install packages and their dependencies, if needed.

list.of.packages <- c("remotes", "Hmisc", "labdsv", "MASS", "vegan")

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]

if(length(new.packages) > 0) {
  install.packages(new.packages, dependencies = TRUE) 
  print(paste0("The following package was installed:", new.packages)) 
} else if(length(new.packages) == 0) {
    print("All packages were already installed previously")
  }

# Load all required libraries at once
lapply(list.of.packages, require, character.only = TRUE, quietly = TRUE)
```

# ¿ propos de cet atelier
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=repo&message=dev&color=6f42c1&logo=github)](https://github.com/QCBSRworkshops/workshop10)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=wiki&message=10&logo=wikipedia)](https://wiki.qcbs.ca/r_atelier10)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=Diapos&message=10&color=red&logo=html5)](https://qcbsrworkshops.github.io/workshop10/workshop10-fr/workshop10-fr.html)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=Diapos&message=10&color=red&logo=adobe-acrobat-reader)](https://qcbsrworkshops.github.io/workshop10/workshop10-fr/workshop10-fr.pdf)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=script&message=10&color=2a50b8&logo=r)](https://qcbsrworkshops.github.io/workshop10/workshop10-fr/workshop10-fr.R)

---

# Packages requis

* [Hmisc](https://cran.r-project.org/package=Hmisc)
* [labdsv](https://cran.r-project.org/package=labdsv)
* [MASS](https://cran.r-project.org/package=MASS)
* [vegan](https://cran.r-project.org/package=vegan)

<br>

```R
install.packages(c('Hmisc', 'labdsv', 'MASS', 'vegan'))
```

---
# Objectifs d'apprentissage

##### Utiliser R pour faire des ordinations non-contraintes


---
class: inverse, center, middle

# Introduction


---

# Introduction

L'atelier pr√©c√©dent (#9) a offert un aper√ßu des analyses multivari√©es de base:

* Mesures de distances et transformations de donn√©es
* Groupement hi√©rarchique
* Ordinations sans contraintes (PCA, PCoA, CA, nmDS)
<br>

Celles-ci permettent de relever des .alert[tendances] dans la structure des communaut√©s d'esp√®ces ou des descripteurs.
<br>

L'atelier #10 montre des analyses permettant d'explorer comment les variables environnementales .alert[**expliquent**] ces tendances.

---
# Introduction

Le pr√©sent atelier se concentrera sur les analyses .alert[**sous contraintes**]:

* Analyse canonique de redondances (ACR ou RDA)
* Partitionnement de la variation
* Arbre de r√©gression multivari√© (ARM ou MRT)
* Analyse lin√©aire discriminante (ALD ou LDA)
<br>

Ces analyses nous permettrons de .alert[**d√©crire**] et de .alert[**pr√©dire**] les relations entre la structure des communaut√©s et les variables environnementales.
<br>

On pourra alors .alert[**tester des hypoth√®ses**]!

---
# Code et donn√©es

Lien vers le code et les jeux de donn√©es: [qcbs.ca/wiki/r_workshop10](http://qcbs.ca/wiki/r_atelier10)

T√©l√©chargez le code R et les donn√©es requises pour cet atelier:
* Code R
* Donn√©es:
  * DoubsEnv
  * DoubsSpe
  * DoubsSpa
  * Donn√©es test pour l'analyse lin√©aire discriminante

---
# Librairies

Assurez-vous d'installer et d'importer les librairies suivantes dans R Studio (proc√©dure fournie dans le code R):
* .comment[vegan] .small[(for multivariate analyses)]
* .comment[labdsv] .small[(pour identification d'esp√®ces indicatrices pour l'arbre de r√©gression multivari√©))]
* .comment[plyr] .small[(classification pour l'analyse lin√©aire discriminante)]
* .comment[MASS] .small[(for l'analyse lin√©aire discriminante)]
* .comment[rdaTest] package .alert[(voir code R)]
* .comment[mvpart] package .alert[(voir code R)]
* .comment[MVPARTwrap] package .alert[(voir code R)]

---
# Suivre l'atelier

Quelques conseils:
* Cr√©ez votre propre code (ou commentez le code R fourni)
* √âvitez de copier-coller, ou d'ex√©cuter le code directement du script fourni
* N'oubliez pas de bien d√©finir votre r√©pertoire de travail (le dossier contenant les fichiers requises pour l'atelier)

---

class: inverse, center, middle

# Exploration et pr√©paration des donn√©es

---
# Introduction aux donn√©es

#### Rivi√®re Doubs (Verneaux 1973)

.pull-left[Donn√©es d'abondances d'esp√®ces de communaut√©s de poissons de la rivi√®re Doubs.
 * 27 esp√®ces
 * 30 sites
 * 11 variables environnementales

![:scale 100%](images/Doubs_Laissey.jpg)
 ]

.pull-right[

![:scale 100%](images/Doubs_carte.jpg)]

---
# Charger les donn√©es

.alert[Assurez-vous que les fichiers se trouvent dans votre r√©pertoire de travail!]

Chargez la matrice d'abondances d'esp√®ces (*doubsspe.csv*):

```{r, echo = TRUE}
# Assurez vous que les fichiers se trouvent dans votre r√©pertoire de travail!
spe <- read.csv("data/doubsspe.csv", row.names = 1)
spe <- spe[-8,] # Supprimer site 8 (pas d'esp√®ces).
```

Chargez la matrice de donn√©es environnementales (*doubsenv.csv* ):

```{r, echo = TRUE}
env <- read.csv("data/doubsenv.csv", row.names = 1)
env <- env[-8,] # Supprimer site 8 (pas d'esp√®ces).
```

.alert[Note]: N'ex√©cuter qu'une seule fois!

---
# Donn√©es d'abondances d'esp√®ces

Explorons la matrice des abondances d'esp√®ces:
```{r, echo = TRUE, results = 'hide'}
names(spe) # voir les noms des colonnes (esp√®ces)
dim(spe) # dimensions de la matrice
head(spe) # 5 premi√®res lignes
str(spe) # structure interne de la matrice
summary(spe) # statistiques descriptives des objets (min, moyenne, max, etc.)
```

```{r, echo = FALSE}
dim(spe)
```
---
# Distribution des abondances d'esp√®ces

Explorons la structure de la communaut√©:
```{r, echo = TRUE, results = 'hide', fig.width = 6, fig.height = 3.5}
# Compter la fr√©quence d'esp√®ces dans chaque classe d'abondance
ab <- table(unlist(spe))
# Visualiser cette distribution
barplot(ab, las = 1,
        xlab = "Abundance class", ylab = "Frequency",
        col = grey(5:0/5))
```
.alert[Notice]: Il y a beaucoup de z√©ros.

---
# Distribution des abondances d'esp√®ces

Comptez le nombre absences dans les donn√©es d'abondances.
```{r}
sum(spe == 0)
```
<br>
Regardez la proportion d'absences dans les donn√©es d'abondances.
```{r}
sum(spe == 0)/(nrow(spe)*ncol(spe))
```

---
# Transformation des donn√©es d'abondances

.alert[**Plus de 50%**] des donn√©es d'abondances consiste d'absences. C'est √©lev√©, mais pas inhabituel pour ce type de donn√©es.
<br>
Par contre, il faut √©viter que les **double z√©ros** soient consid√©r√©s comme une similarit√© entre sites.
* Nous appliquerons alors une .alert[transformation Hellinger] aux donn√©es d'abondances d'esp√®ces.
<br>
```{r}
# a fonction decostand() dans la libraire vegan nous facilite la t√¢che:
library(vegan)
spe.hel <- decostand(spe, method = "hellinger")
```

---
# Donn√©es environnementales

Explorons les donn√©es environnementales:
```{r, echo = TRUE, results = 'hide'}
names(env) # noms des objets (variables environnementales)
dim(env) # dimensions de la matrice
head(env) # 5 premi√®res lignes
str(env) # structure des objets
summary(env) # statistiques descriptives (min, moyenne, max, etc.)
```

```{r, echo = FALSE}
names(env) # noms des objets (variables environnementales)
dim(env) # structure des objets
```

---
# Colin√©arit√©

```{r, fig.height = 5, fig.width = 9}
# On peut √©galement d√©tecter (visuellement) les colin√©arit√©s entres variables:
pairs(env)
```
.alert[Note:] Colin√©arit√© entre quelques variables... .small[(das vs. alt, das vs. deb, das vs. dur, das vs. nit, oxy vs. dbo, etc.)]

---
# Standardisation des donn√©es

Il est impossible de comparer les effets de variables d'unit√©s diff√©rentes.
<br>
Avant d'effectuer les analyses qui suivent, les donn√©es doivent donc √™tre .alert[standardis√©es].

```{r}
# standardiser les donn√©es
env.z <- decostand(env, method = "standardize")

# centrer les donn√©es (moyenne ~ 0)
round(apply(env.z, 2, mean), 1)

# r√©duire les donn√©es (√©cart type = 1)
apply(env.z, 2, sd)
```

---

class: inverse, center, middle

# Analyses canoniques

---
# Analyses canoniques

Les analyses canoniques nous permettent:
- d'identifier les .comment[relations] entre un ensemble de variables r√©ponses et un ensemble de variables explicatives
- de tester des .alert[hypoth√®ses √©cologiques] √† propos de ces relations
- de faire des .comment[pr√©dictions]

---

class: inverse, center, middle

# Analyses canoniques
## Analyse canonique de redondances (RDA)

---
# Analyse canonique de redondances (RDA)

L'analyse canonique de redondances est une ordination .alert[sous contraintes].
- extension directe de la r√©gression multiple.
- mod√©lise l‚Äôeffet d‚Äôune matrice X .small[(variables explicatives)] sur une matrice Y .small[(variables r√©ponses)]

.center[ ![:scale 60%](images/RDA.png)]

Variables peuvent √™tre quantitatives, qualitatives, ou binaires (0/1).
- .alert[transformez] et .alert[standardisez] les variables avant d'effectuer une RDA.

---
# Effectuer une RDA dans R

Pr√©parer les donn√©es
```{r}
# On utilisera nos donn√©es explicatives standardis√©es
# Enlever la variable "distance from the source" (colin√©arity avec plusieurs variables)
env.z <- subset(env.z, select = -das)
```

--
Effectuer une RDA
```{r}
# Mod√®lise l'effect de tous les variables environnementales sur la composition en esp√®ces des communaut√©s
spe.rda <- rda(spe.hel ~ ., data = env.z)
```

--
Extraire les r√©sultats de la RDA
```{r, eval = FALSE, results = 'hide'}
summary(spe.rda, display = NULL)
```

---
# Sortie d'une RDA

.center[ ![:scale 70%](images/RDAOutput.png)]

* **Constrained Proportion**: variance de Y expliqu√©e par X .alert[(73.41%)]
* **Unconstained Proportion**: variance in Y non expliqu√©e par .alert[(26.59%)]

  <br>

.small[Les variables environnementales mesur√©es expliquent .alert[73.41%] de la variation dans la composition en esp√®ces des communaut√©s de poissons dans la rivi√®re Doubs.]

---
# S√©lection de variables

Une .alert[s√©lection progressive] peut √™tre effectu√©e afin de s√©lectionner les variables explicatives significatives.

<br>
.comment[**Quelles variables contribuent de fa√ßon significative au pouvoir explicatif du mod√®le?**]
--
```{r}
# S√©lection progressive de variables:
fwd.sel <- ordiR2step(rda(spe.hel ~ 1, data = env.z), # mod√®le le plus simple
               scope = formula(spe.rda), # mod√®le "complet"
               direction = "forward",
               R2scope = TRUE, # limit√© par le R2 du mod√®le "complet"
               pstep = 1000,
               trace = FALSE) # mettre TRUE pour voir le processus du s√©lection!
```

.small[Essentiellement, on ajoute une variable √† la fois au mod√®le, et on retient la variable si elle augmente significativement le R2 ajust√© du mod√®le.]

---
# S√©lection de variables

- Quelles variables ont √©t√© s√©lectionn√©es?
```{r}
fwd.sel$call
```

--

- Quel est le R2 ajust√© d'une RDA incluant seulement les variables significatives?
```{r}
spe.rda.signif <- rda(spe.hel ~ alt + oxy + dbo, data = env.z)
RsquareAdj(spe.rda.signif)
```

---
# Tester la significativit√© d'une RDA

Utilisez .alert[anova.cca()] pour tester la significativit√© globale de notre RDA
```{r}
anova.cca(spe.rda.signif, permutations = 1000)
```

On peut aussi tester la significativit√© des axes!
```{r, results = 'hide'}
anova.cca(spe.rda.signif, permutations = 1000, by = "axis")
```

---
# Repr√©sentation graphique des RDAs

Une RDA permet la **visualization simultan√©e** des variables r√©ponses et explicatives .comment[(i.e. esp√®ces et variables environmentales)].
<br>
--
<br>
Comme pour la PCA, on doit choisir le .alert[cadrage]:
<br>

| Type 1                                           | Type 2                                            |
| -------------------------------------------------|---------------------------------------------------|
| distances entre objects ‚âà distances euclidiennes | angles entre variables ‚âà leur corr√©lation         |


---
# Triplot RDA: Cadrage de type 1

.pull-left[
```{r, fig.height = 6.5, fig.width = 6, strip.white = TRUE}
ordiplot(spe.rda.signif,
         scaling = 1,
         type = "text")
```
]

.pull-right[
######Le cadrage 1 permet d'interpr√©ter les .alert[distances] entre objets (esp√®ces).

.small[
* Les communaut√©s dans les sites (chiffres) .comment[plus rapproch√©s] ont des compositions plus similaires.
* Les esp√®ces .comment[plus rapproch√©s] occupent souvent les m√™mes sites.
]
]

---
# Triplot RDA: Cadrage de type 2

.pull-left[
```{r, fig.height = 6.5, fig.width = 6, strip.white = TRUE}
ordiplot(spe.rda.signif,
         scaling = 2,
         type = "text")
```
]

.pull-right[
######Le cadrage 2 permet d‚Äôinterpr√©ter les .alert[relations] entre variables X et Y.
.small[
* .comment[Longues] fl√®ches = cette variable explique fortement la variation dans la matrice Y d'abondances
* Fl√®ches pointant des .comment[directions oppos√©es] = relation n√©gative
* Fl√®ches pointant la .comment[m√™me direction] = relation positive
]
]

---
# Configuration des triplots RDA

Les fonctions plot() et ordiplot() produisent des triplots rapidement et facilement, mais on peut aussi configurer les graphiques manuellement.

```{r, echo = FALSE}
## extrait le % expliqu√© par les 2 axes
perc <- round(100*(summary(spe.rda.signif)$cont$importance[2, 1:2]), 2)
## scores => coordonn√©es
sc_si <- scores(spe.rda.signif, display="sites", choices=c(1,2), scaling=1)
sc_sp <- scores(spe.rda.signif, display="species", choices=c(1,2), scaling=1)
sc_bp <- scores(spe.rda.signif, display="bp", choices=c(1, 2), scaling=1)
## plot
plot(spe.rda.signif, scaling=1, main="Triplot RDA - scaling 1", type="none", xlab=paste0("RDA1 (", perc[1], "%)"), ylab = paste0("RDA2 (", perc[2], "%)"), xlim=c(-1,1), ylim=c(-1,1))
points(sc_si, pch=21, col="black", bg="steelblue", cex=1.2)
points(sc_sp, pch=22, col="black", bg = "#f2bd33", cex=1.2)
text(sc_sp, labels = rownames(sc_sp), col="black", cex=0.6)
arrows(0,0, sc_bp[,1], sc_bp[,2], col="#f04f6c", lwd = 3)
text(x = sc_bp[,1] -0.1, y = sc_bp[,2] - 0.03, labels=rownames(sc_bp), col="#f04f6c", cex=1, font = 2)
```

Voir le wiki pour plus de d√©tails!

---
# D√©fi 1 ![:cube]()

Effectuer une RDA pour mod√®liser les effect des variables environnementales (.comment[mite.env]) sur l‚Äôabondance des esp√®ces d'acariens (.comment[mite]).
<br>
.small[
Chargez les donn√©es:
```{r}
# Charger les donn√©es d'abondance des esp√®ces d'acariens
data("mite")

# Charger les donn√©es environnementales
data("mite.env")
```

Rappel de fonctions utiles:
```{r, eval = FALSE}
decostand()
rda()
ordiR2step()
anova.cca()
ordiplot()
```
]

---
# D√©fi 1: Solution

√âtape 1: Pr√©parer les donn√©es
```{r}
# Transformer les donn√©es d'abondances
mite.spe.hel <- decostand(mite, method = "hellinger")

# Standardiser les donn√©es environmentales quantiatives
mite.env$SubsDens <- decostand(mite.env$SubsDens, method = "standardize")
mite.env$WatrCont <- decostand(mite.env$WatrCont, method = "standardize")
```

---
# D√©fi 1: Solution

√âtape 2: S√©lectionner les variables environnementales
```{r}
# RDA avec tous les variables environnementales
mite.spe.rda <- rda(mite.spe.hel ~ ., data = mite.env)

# S√©lection progressive des variables environnementales significatives
fwd.sel <- ordiR2step(rda(mite.spe.hel ~ 1, data = mite.env),
                      scope = formula(mite.spe.rda),
                      direction = "forward",
                      R2scope = TRUE, pstep = 1000, trace = FALSE)
fwd.sel$call
```

---
# D√©fi 1: Solution

√âtape 3: Effectuer l'RDA et extraire le R2 ajust√©
```{r}
# Refaire la RDA avec seulement les variables significatives
mite.spe.rda.signif <- rda(mite.spe.hel ~ WatrCont + Shrub +
                           Substrate + Topo + SubsDens,
                           data = mite.env)

# Calculer le R2 ajust√©
RsquareAdj(mite.spe.rda.signif)$adj.r.squared

```

---
# D√©fi 1: Solution

√âtape 4: Tester la significativit√© globale du mod√®le
```{r}
anova.cca(mite.spe.rda.signif, step = 1000)
```

Les variables environnementales s√©lectionn√©es expliquent .alert[43.7% (p = 0.001)] de la variation dans la composition de communaut√©s des acariens.

---
# D√©fi 1: Solution

√âtape 5: Triplot!
.pull-left[
```{r, fig.height = 6.5}
ordiplot(mite.spe.rda.signif,
         scaling = 1,
         main = "Cadrage 1")
```
]
.pull-right[
```{r, fig.height = 6.5}
ordiplot(mite.spe.rda.signif,
         scaling = 2,
         main = "Cadrage 2")
```

]

---

class: inverse, center, middle

# Analyses canoniques
## RDA partielle

---
# RDA partielle

* Cas particulier de la RDA en pr√©sence d‚Äôune matrice W de variables explicatives additionnelles, appel√©es co-variables
  * Mod√®le lin√©aire de l‚Äôeffet de X sur Y, ajust√© pour tenir compte de l‚Äôeffet des .alert[co-variables W].

.center[ ![:scale 90%](images/PartialRDA.png)]

---
# Applications de la RDA partielle

* √âvaluer l‚Äôeffet de variables environnementales sur la composition des communaut√©s, prenant en compte l'.alert[effet de covariables] de moindre int√©r√™t.
* .alert[Isoler] les effets d'un ou plusieurs groupes de variables explicatives.

.center[ ![:scale 90%](images/PartialRDA.png)]

---
# RDA partielle: donn√©es Doubs

√âvaluons l'effet de la .comment[chimie de l'eau] (X) sur l‚Äôabondance des poissons en tenant compte de .comment[covariables topographiques] (W).

```{r}
# Divisez le tableau de donn√©es environnementales en deux:
# variables topographiques et chimiques
env.topo <- subset(env.z, select = c(alt, pen, deb))
env.chem <- subset(env.z, select = c(pH, dur, pho, nit, amm, oxy, dbo))

# Faire la RDA partielle
spe.partial.rda <- rda(spe.hel, env.chem, env.topo)
```

--

.small[
.alert[Note]: Syntaxe alternative pour une RDA partielle:
```{r, eval = FALSE}
spe.partial.rda <- rda(spe.hel ~ pH + dur + pho + nit + amm + oxy + dbo +
                       Condition(alt + pen + deb),
                       data = env.z)
```
]

---
# R√©sultats d'une RDA partielle

```{r, eval = FALSE, results = 'hide'}
# Extraire les r√©sultats
summary(spe.partial.rda, display = NULL)
```

.center[ ![:scale 45%](images/PartialRDAOutput.png)]

.small[
* **Conditioned Proportion**:  variance de Y expliqu√©e par W .alert[(41.53%)]
* **Constrained Proportion**: variance de Y expliqu√©e par X .alert[(31.89%)]
* **Unconstained Proportion**: variance de Y non expliqu√©e .alert[(26.59%)]

  <br>
.comment[La chimie de l‚Äôeau explique .alert[31.89%] de l‚Äôabondance des esp√®ces de poissons, tandis que la topographie explique .alert[41.53%] de la variation en abondances des poissons.]
]

---
# Tester la significativit√©

Extraire le R2 ajust√© du mod√®le:
```{r}
RsquareAdj(spe.partial.rda)$adj.r.squared
```

--

Ensuite, tester la significativit√© globale de notre RDA partielle
```{r}
anova.cca(spe.partial.rda, step = 1000)
```

---
# Repr√©sentation graphique

.small[
```{r}
ordiplot(spe.partial.rda, scaling = 2,
         main = "Doubs River partial RDA - Scaling 2")
```
--

.alert[Note]: Les variables topographiques ne sont pas repr√©sent√©es. Pourquoi?]

---
# D√©fi 2 ![:cube]()

.small[
Effectuez une RDA partielle de l‚Äôabondance des esp√®ces de mites en fonction des variables environnementales, tenant compte de l‚Äôeffet du substrat (SubsDens, WaterCont and Substrate).
* Quel pourcentage de variance est expliqu√© par les variables environnementales?
* Le mod√®le est-il significatif?
* Quels sont les axes significatifs?

<br>

Rappel des donn√©es et fonctions utiles:
```{r, eval = FALSE}
mite.spe.hel
mite.env
rda()
summary()
RsquareAdj()
anova.cca()
```
]

---
# D√©fi 2: Solution

Nos donn√©es sont d√©j√† transform√©s et standardis√©s.
<br>
Commen√ßons alors par la RDA partielle:
```{r, results = 'hide'}
mite.spe.subs <- rda(mite.spe.hel ~ Shrub + Topo
                     + Condition(SubsDens + WatrCont + Substrate),
                     data = mite.env)

# Extraire les r√©sultats
summary(mite.spe.subs, display = NULL)
```
--
Shrub et Topo expliquent .alert[9.8%] de la variation de l‚Äôabondance de mites, tandis que le substrat explique .alert[42.8%] de cette variation.

---
# D√©fi 2: Solution

* Le mod√®le est-il significatif?
```{r}
anova.cca(mite.spe.subs, step = 1000)
```

---
# D√©fi 2: Solution

* Quels sont les axes significatifs?
```{r}
anova.cca(mite.spe.subs, step = 1000, by = "axis")
```

---

class: inverse, center, middle

# Analyses canoniques
## Partitionnement de la variation

---
# Partitionnement de la variation

Divise la variation d‚Äôune matrice de variable r√©ponse en 2, 3, ou 4 matrices de variables explicatives.
* e.g. variables locales vs. √† large √©chelle
* e.g. abiotique vs. biotique

<br>
.center[![:scale 85%](images/VarPart_Matrices.png)]

---
# Partitionnement de la variation

.center[![:scale 85%](images/VarPart.png)]

---
# Partitionnement de la variation dans R

.small[.alert[Note]: Assurez-vous que la libraire *vegan* est charg√©e!

```{r}
spe.part.all <- varpart(spe.hel, env.chem, env.topo)
spe.part.all$part # extraire r√©sultats
```
]

---
# Diagramme Venn

```{r, strip.white = TRUE, fig.width = 6, fig.height = 6}
plot(spe.part.all,
     Xnames = c("Chem", "Topo"), # noms des matrices explicatives
     bg = c("seagreen3", "mediumpurple"), alpha = 80,
     digits = 2,
     cex = 1.5)
```

---
# Tester la significativit√©

.center[![:scale 75%](images/VarPart.png)]

* La significativit√© de la fraction partag√©e [b] ne peut .alert[pas] √™tre test√©e.
* Mais, on peut tester la significativit√© des autres fractions!

---
# Significativit√©: X1 [a+b]

.center[![:scale 30%](images/VarPart_small.png)]

.small[
[a+b] Chimie sans tenir compte de topographie
```{r}
anova.cca(rda(spe.hel, env.chem))
```
]

---
# Significativit√©: X2 [b+c]

.center[![:scale 30%](images/VarPart_small.png)]

.small[
[b+c] Topographie sans tenir compte de chimie
```{r}
anova.cca(rda(spe.hel, env.topo))
```
]

---
# Significativit√©: Fractions individuelles

.center[![:scale 30%](images/VarPart_small.png)]
.small[
[a] Chimie (ajust√© pour tenir compte de topographie)
```{r}
anova.cca(rda(spe.hel, env.chem, env.topo))
```

.alert[Note:] Remarquez qu'il s'agit d'une RDA partielle!
]

---
# Significativit√©: Fractions individuelles

.center[![:scale 30%](images/VarPart_small.png)]

.small[
[c] Topographie (ajust√© pour tenir compte de chimie)
```{r}
anova.cca(rda(spe.hel, env.topo, env.chem))
```
]

---
# D√©fi 3 ![:cube]()

.small[
Partitionnez la variation de l‚Äôabondance des esp√®ces de mites entres des variables de substrat (SubsDens, WaterCont) et des variables spatiales significatives.
* Quelle est la proportion de variance expliqu√©e par le substrat? par l'espace?
* Quelles sont les fractions significatives?
* Diagramme Venn des r√©sultats!


Chargez les variables spatiales:
```{r}
data("mite.pcnm")
```

Rappel de fonctions utiles:
```{r, eval = FALSE}
ordiR2step()
varpart()
anova.cca(rda())
plot()
```
]

---
# D√©fi 3: Solution

√âtape 1: S√©lection de variables spatiales significatives
```{r}
# Mod√®le RDA avec tous les variables spatiales
full.spat <- rda(mite.spe.hel ~ ., data = mite.pcnm)

# S√©lection progressive des variables spatiales
spat.sel <- ordiR2step(rda(mite.spe.hel ~ 1, data = mite.pcnm),
               scope = formula(full.spat),
               R2scope = RsquareAdj(full.spat)$adj.r.squared,
               direction = "forward",
               trace = FALSE)
spat.sel$call
```

---
# D√©fi 3: Solution

√âtape 2: Cr√©er sous-groupes de variables explicatives
```{r}
# Variables de substrat
mite.subs <- subset(mite.env, select = c(SubsDens, WatrCont))

# Variables spatiales significatives
mite.spat <- subset(mite.pcnm,
                    select = names(spat.sel$terminfo$ordered))
                    # pour rapidement acc√®der aux variables s√©lectionn√©es
```

---
# D√©fi 3: Solution

√âtape 3: Partitionnement de la variation
```{r}
mite.part <- varpart(mite.spe.hel, mite.subs, mite.spat)
mite.part$part$indfract # extraire r√©sultats
```

* Quelle est la proportion de variance expliqu√©e par le substrat?
 * .alert[5.9%]

* Quelle est la proportion de variance expliqu√©e par l'espace?
  * .alert[19.4%]

---
# D√©fi 3: Solution

√âtape 4: Quelles sont les fractions significatives?
```{r, results = 'hide'}
# [a]: Substrat seulement
anova.cca(rda(mite.spe.hel, mite.subs, mite.spat))
# p = 0.001 ***

# [c]: Espace seulement
anova.cca(rda(mite.spe.hel, mite.spat, mite.subs))
# p = 0.001 ***
```

--
.comment[Alors, quels sont les effets de substrat et de l'espace sur les abondances d'esp√®ces de mites?]

---
# D√©fi 3: Solution

√âtape 5: Diagramme Venn
```{r, fig.height=6, fig.width=6}
plot(mite.part, digits = 2, cex = 1.5,
     bg = c("pink", "skyblue"), alpha = 90)
```

---

class: inverse, center, middle
# Arbre de r√©gression multivari√© (MRT)

---
# Arbre de r√©gression multivari√© (MRT)

.center[![:scale 75%](images/MRT.png)]

L'arbre de r√©gression multivari√© (ARM ou MRT) est une m√©thode de groupement hi√©rarchique sous contrainte.
* Partitionne une matrice r√©ponse quantitative (Y) en sous-groupes sous la contrainte d'une matrice de variables explicatives (X).

---
# Arbre de r√©gression multivari√© (MRT)

.center[![:scale 75%](images/MRT.png)]

L'arbre de r√©gression multivari√© consiste de:
* .alert[Branches]: chaque lign√©e form√©e par un noeud
* .alert[Noeuds]: Point o√π les donn√©es se divisent en 2 groupes (caract√©ris√© par une valeur limite d'une variable explicative)
* .alert[Feuilles]: groupe terminal de sites

---
# Arbre de r√©gression multivari√© (MRT)

Plusieurs avantages:
* N'assume pas de relation lin√©aire entre les matrices Y et X
* Facile √† interpr√©ter et √† visualiser
* Robuste en pr√©sence de valeurs manquantes ou de colin√©arit√©(s) entre les descripteurs
* Valeurs brutes peuvent √™tre utilis√©es (sans transformation)

---
# MRT: La m√©thode

La m√©thode implique deux volets s'effectuant en parall√®le:
1. .comment[Partitionnement] des donn√©es sous contrainte
2. .comment[Validation crois√©e] pour identifier l'arbre ayant le meilleur pouvoir pr√©dictif.
<br>

Choisissez l'arbre selon les objectifs de ton √©tude. G√©n√©ralement, on veut un arbre:
* .comment[parcimonieux]
* mais avec un nombre .comment[informatif] de groupes
* Essentiellement: quel arbre r√©pond √† ta question?


---
# MRT dans R

Dans ce qui suit, nous allons utiliser .alert[`mvpart` qui est archiv√© sur le CRAN]. Nous l'installons depuis GitHub avec le package remotes:

```{R mvpart_install}
remotes::install_github("cran/mvpart")
library(mvpart)
```


---
# MRT dans R

```{r, results = 'hide', fig.show = 'hide', eval = F}
# Enlever la variable ‚Äúdistance from source‚Äù
env <- subset(env, select = -das)

# Cr√©er l'arbre de regression multivari√©
# library(mvpart)
doubs.mrt <- mvpart(as.matrix(spe.hel) ~ ., data = env,
                    xv = "pick", # selection graphique int√©ractive
                    xval = nrow(spe.hel), # nombre de validations
                    xvmult = 100, # nombre de validations multiples
                    which = 4, # identifier les noeuds
                    legend = FALSE, margin = 0.01, cp = 0)
```

---
# MRT dans R: Choisir un arbre

```{r, echo = FALSE, results = 'hide', fig.height = 5, fig.width = 5.5, fig.align = 'center'}
doubs.mrt <- mvpart(as.matrix(spe.hel) ~ ., data = env,
                    xv = "pick",
                    xval = nrow(spe.hel),
                    xvmult = 100,
                    which = 4,
                    legend = FALSE, margin = 0.01, cp = 0, plot.add = FALSE)
```
.small[
* Points verts: Erreur relative
* Points bleus: Erreur relative de validation crois√©e (CVRE)
* Point rouge: Arbre avec la valeur minimale de CVRE
* Point orange: l'arbre le plus petit ayant un CVRE √† 1 √©cart type du CVRE minimal
* Barres vertes: # de fois que chaque taille d'arbre a √©t√© choisi
]

---
# MRT dans R: Choisir un arbre

```{r, echo = FALSE, results = 'hide', fig.height = 5, fig.width = 5.5, fig.align = 'center', eval =FALSE}
doubs.mrt <- mvpart(as.matrix(spe.hel) ~ ., data = env,
                    xv = "pick",
                    xval = nrow(spe.hel),
                    xvmult = 100,  cross-validations
                    which = 4,
                    legend = FALSE, margin = 0.01, cp = 0,
                    plot.add = FALSE)
```

.small[
* Cliquez sur le point bleu correspondant √† la taille de l'arbre choisie!
* Puisqu'on ne sait pas *a priori* comment partitionner ces donn√©es, on choisira .comment[l'arbre le plus petit ayant un CVRE √† 1 √©cart type du CVRE minimal] (i.e. le point orange).
]

---
# MRT dans R: Visualisation

```{r, echo = FALSE, results = 'hide', fig.height = 5.5, fig.width = 5.5}
doubs.mrt <- mvpart(as.matrix(spe.hel) ~ ., data = env,
                    xv = "1se",
                    xval = nrow(spe.hel),
                    xvse = 1,
                    xvmult = 100,
                    which = 4,
                    legend = FALSE, margin = 0.01, cp = 0, prn = FALSE)
```
.small[
* La matrice d'abondances est partitionn√©e selon un seuil d'.alert[altitude (361.5)].
  * "Barplots": abondances d'esp√®ces inclus dans chaque groupe
* Erreur r√©siduelle = 0.563, alors le R2 du mod√®le est .alert[43.7%]
]

---
# MRT dans R: Comparaison d'arbres

Pour choisir un arbre, on peut aussi comparer plusieurs solutions possibles.

Par exemple, consid√©rons une solution de 10 groupes!
```{r, echo = FALSE, results = 'hide', fig.height = 4.5, fig.width = 12}
mvpart(as.matrix(spe.hel) ~ ., data = env,
        xv = "none", # no cross-validation
        size = 10, # set tree size
        which = 4,
        legend = FALSE, margin = 0.01, cp = 0, prn = FALSE)
```

.small[
* L'interpr√©tation est .alert[plus difficile].
* Plus grand pouvoir explicatif, MAIS le pouvoir pr√©dictif (CV Error = 0.671) ressemble √† la solution pr√©c√©dante (CV Error = 0.673).
]

---
# MRT dans R: Comparaison d'arbres

Consid√©rons une solution avec moins (4) de groupes!
.tiny[
```{r, echo = FALSE, results = 'hide', fig.height = 4.5, fig.width =8}
mvpart(as.matrix(spe.hel) ~ ., data = env,
        xv = "none", # no cross-validation
        size = 4, # set tree size
        which = 4,
        legend = FALSE, margin = 0.01, cp = 0, prn = FALSE)
```
]
.small[
* Plus facile √† interpr√©ter!
* Plus grand pouvoir explicatif .alert[(Error)] que notre solution originale
* .alert[Plus grand pouvoir pr√©dictif] que les 2 solutions pr√©c√©dantes (CV Error)
]

---
# MRT dans R: Param√®tre de complexit√©

Le .comment[param√®tre de complexit√© (CP)] repr√©sente la variance expliqu√©e par chaque noeud.
```{r}
doubs.mrt$cptable
```

* CP @ nsplit 0 = R2 de l'arbre au complet
* CP @ autres neouds = R2 de chaque noeud (voir sommaire complet pour la valeur de seuil de chaque noeud)

---
# MRT dans R: Sommaire des r√©sultats

Pour acc√®der au sommaire des r√©sultats:
.tiny[
```{r}
summary(doubs.mrt)
```
]

---
# MRT dans R: Esp√®ces discriminantes

On peut aussi d√©terminer quelles esp√®ces contribuent le plus √† la variance expliqu√©e par chaque n≈ìud (.alert[esp√®ces discriminantes]), ou quels sites sont inclus dans chaque feuille (groupe).
<br>
Pour ceci, on peut utiliser la libraire **MVPARTwrap**

.alert[MVPARTwrap est archiv√©, on utilise remotes pour l'installer depuis GitHub]

```{R MVPARTwrap_install}
remotes::install_github("cran/MVPARTwrap")
library(MVPARTwrap)
```

---
# MRT dans R: Esp√®ces discriminantes

```{r, results = 'hide'}
# Cr√©er un sommaire plus informatif et moins dense
doubs.mrt.wrap <- MRT(doubs.mrt, percent = 10, species = colnames(spe.hel))

# Voir le sommaire
summary(doubs.mrt.wrap)
```

---
# MRT dans R: Esp√®ces discriminantes

Pour voir la contribution de chaque esp√®ce √† la variance expliqu√©e par noeud:
.small[
```{r}
summary(doubs.mrt.wrap)
```
]

---
# MRT dans R: Esp√®ces discriminantes

Pour d√©terminer les esp√®ces discriminantes .alert[significatives] pour chaque groupe:

.tiny[
```{r}
library(labdsv)

# Calcul d'une valeur indval pour chaque esp√®ce
doubs.mrt.indval <- indval(spe.hel, doubs.mrt$where)

# Extraire les esp√®ces indicatrices √† chaque noeud
doubs.mrt.indval$maxcls[which(doubs.mrt.indval$pval <= 0.05)]

# Extraire leur valeur indval
doubs.mrt.indval$indcls[which(doubs.mrt.indval$pval <= 0.05)]
```
]

* Les principales esp√®ces discriminantes au premier noeud sont TRU, VAI et ABL.
* TRU et VAI contribuent beaucoup √† la branche de gauche, alors que ABL est davantage indicatrice des sites √† basse altitude (<361.5m).

---
# D√©fi 4 ![:cube]()

.small[
Cr√©ez un arbre de r√©gression multivari√© pour les donn√©es .comment[mite].
* Choisir l'arbre le plus petit √† 1 √©cart type du CVRE minimal.
* Quelle est la variance totale expliqu√©e par cet arbre?
* Combien y a-t-il de feuilles?
* Quels sont les 3 principales esp√®ces discriminantes?
]
<br>
.small[
Rappel: chargez les donn√©es!
```{r}
data("mite")
data("mite.env")
```

Rappel de fonctions utiles:
```{r, eval = FALSE}
?mvpart() # argument 'xv'!
?MRT()
summary()
```
]
---
# D√©fi 4: Solution

√âtape 1: Cr√©er un arbre de r√©gression multivari√©
```{r, results = 'hide', fig.height = 4.5, fig.width = 4.5}
mite.mrt <- mvpart(as.matrix(mite.spe.hel) ~ ., data = mite.env,
                   xv = "1se",
                   xval = nrow(mite.spe.hel),
                   xvmult = 100,
                   which = 4, legend = FALSE, margin = 0.01, cp = 0,
                   prn = FALSE)
```

---
# D√©fi 4: Solution

```{r, echo = FALSE, results = 'hide', fig.height = 5, fig.width = 5}
mite.mrt <- mvpart(as.matrix(mite.spe.hel) ~ ., data = mite.env,
                   xv = "1se", # choose smallest tree within 1 SE
                   xval = nrow(mite.spe.hel),
                   xvmult = 100,
                   which = 4, legend = FALSE, margin = 0.01,
                   cp = 0, prn = FALSE)
```
.small[
* Quelle est la variance totale expliqu√©e (R2) par cet arbre?
  * 1 - Error = 0.252, alors l'arbre explique .alert[25.2%] de la variantion dans la matrice d'abondances.

* Combien y a-t-il de feuilles?
  * 2 feuilles
]

---
# D√©fi 4: Solution


Quels sont les 3 principales esp√®ces discriminantes pour .alert[noeud #1]?
```{r, results = 'hide'}
# Cr√©er sommaire plus informatif
mite.mrt.wrap <- MRT(mite.mrt,
                     percent = 10,
                     species = colnames(mite.spe.hel))

# Voir sommaire (pour voir les esp√®ces discriminantes)
summary(mite.mrt.wrap)
```

---
# D√©fi 4: Solution

Quels sont les 3 principales esp√®ces discriminantes pour .alert[noeud #1]?
* LCIL, LRUG, Ceratoz1

.center[![:scale 40%](images/Challenge4_IndVal.png)]

---

class: inverse, center, middle
# Analyse discriminante lin√©aire (LDA)

---
# Analyse discriminante lin√©aire (LDA)

* D√©termine si une matrice de variables ind√©pendantes explique bien un groupement √©tabli *a priori*
  * e.g. pr√©dire l‚Äôappartenance d‚Äôune esp√®ce de poisson √† un groupe (marin vs. eau douce) selon sa morphologie

.center[![:scale 60%](images/LDA_FishExample.jpg)]

---
# LDA dans R: Rivi√®re Doubs

G√©n√©ralement, les variables environnementales changent avec la latitude.

<br>
--
.comment[Si on classifie les sites de la rivi√®re Doubs selon la latitude, √† quel point les variables environnementales expliquent-elles ces groupements?]
* Une LDA permet de r√©pondre √† cette question.

---
# LDA dans R: Rivi√®re Doubs

Commen√ßons par charger les donn√©es spatiales des sites:
```{r}
# charger les donn√©es spatiales des sites Doubs:
spa <- read.csv("data/doubsspa.csv", row.names = 1)
spa$site <- 1:nrow(spa) # assigner un chiffre par site
spa <- spa[-8,] # enlever le site #8
```

--

Ensuite, on peut classifier les sites dans 3 groupes de latitudes:
```{r}
spa$group <- NA # cr√©er colonne "group"
spa$group[which(spa$y < 82)] <- 1
spa$group[which(spa$y > 82 & spa$y < 156)] <- 2
spa$group[which(spa$y > 156)] <- 3
```

---
# LDA dans R: Rivi√®re Doubs

Visualisons ces regroupements par latitude:
```{r, fig.width = 5.5, fig.height = 5.5}
plot(spa$x, spa$y, col = spa$group, pch = 16, cex = 1.5)
```

---
# LDA dans R

.alert[Note]: Normalement, nous devons v√©rifier que les matrices de covariance des variables explicatives sont homog√®nes (voir Borcard et al. 2011).

Pour les besoins de l'atelier, on passera directement √† la LDA:
```{r}
# charger la libraire requise
library(MASS)

# faire la LDA
LDA <- lda(env, spa$group)
```

---
# LDA dans R: V√©rification

.small[On peut ensuite voir comment les sites sont classifi√©s, et si cette classification est exacte.

```{r}
# classification des objets en fonction de la LDA
spe.class <- predict(LDA)$class

# probabilit√©s que les objets appartiennent √† chaque groupe a posteriori
spe.post <- predict(LDA)$posterior

# tableau des classifications a priori et pr√©dites
(spe.table <- table(spa$group, spe.class))

# proportion de classification correcte
diag(prop.table(spe.table, 1))
```

Tous les sites ont √©t√© correctement classifi√©s dans leur groupe de latitude en fonction des variables environnementales.]

---
# LDA dans R: Pr√©dictions

On peut maintenant utiliser la LDA pour classifier de nouveaux sites dans les groupes de latitude.
--

Tentons de .alert[pr√©dire la classification] de 5 nouveaux sites √† l'aide de notre LDA:
.small[
```{r}
# charger les nouvelles donn√©es
classify.me <- read.csv("data/classifyme.csv", header = TRUE)
# classify.me <- classify.me[,-1] # remove das variable

# pr√©dire le groupement des nouvelles donn√©es
predict.group <- predict(LDA, newdata = classify.me)

# donner la classification pour chaque site
predict.group$class
```
]

---
# D√©fi 5 ![:cube]()

.small[Cr√©ez 4 groupes de latitude √† partir des donn√©es .comment[mite.xy]. Ensuite, une LDA sur les donn√©es environnementales .comment[(mite.env)] des acariens (.comment[SubsDens] et .comment[WatrCont]).
* Quelle proportion de sites ont √©t√© classifi√©s correctement au groupe 1? Au groupe 2?

<br>
Chargez .comment[mite.xy]:
```{r}
data(mite.xy)
```

Rappel de fonctions utiles:
```{r, eval = FALSE}
lda()
predict()
table()
diag()
```
]

---
# D√©fi 5: Solution

√âtape 1: Cr√©er 4 groupes de latitude
.small[
```{r}
# num√©roter les sites
mite.xy$site <- 1:nrow(mite.xy)

# trouver une √©tendue √©gale de latitudes par groupe
(max(mite.xy[,2])-min(mite.xy[,2]))/4

# classifier les sites dans 4 groupes de latitude
mite.xy$group <- NA # nouvelle colonne "group"
mite.xy$group[which(mite.xy$y < 2.5)] <- 1
mite.xy$group[which(mite.xy$y >= 2.5 & mite.xy$y < 4.9)] <- 2
mite.xy$group[which(mite.xy$y >= 4.9 & mite.xy$y < 7.3)] <- 3
mite.xy$group[which(mite.xy$y >= 7.3)] <- 4
```
]

√âtape 2: Faire la LDA
.small[
```{r}
LDA.mite <- lda(mite.env[,1:2], mite.xy$group)
```
]

---
# D√©fi 5: Solution

√âtape 3: V√©rifier la classification
.small[
```{r}
# classification des objects en fonction de la LDA
mite.class <- predict(LDA.mite)$class
# tableeau de classifications  (prior versus predicted)
(mite.table <- table(mite.xy$group, mite.class))
# proportion de classifications exactes
diag(prop.table(mite.table, 1))
```

Quelle proportion de sites ont √©t√© classifi√©s correctement au groupe 1? Au groupe 2?
* .alert[60%] des sites ont √©t√© classifi√©s correctement dans group1, et .alert[64.7%] dans group2.]

---

class: inverse, center, bottom

# Merci d'avoir particip√© √† cet atelier!

![:scale 50%](images/qcbs_logo.png)
